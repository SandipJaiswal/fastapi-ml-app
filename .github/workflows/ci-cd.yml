name: CI/CD FastAPI ML App - Multi-Repo GitOps

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY_URL: "192.168.0.200:5000"
  IMAGE_NAME: "fastapi-ml-app"
  DEPLOY_REPO: "SandipJaiswal/fastapi-ml-deploy"
  ARGOCD_SERVER: "192.168.0.201:80"

jobs:
  # üß™ CI Pipeline: Test and Build
  ci-pipeline:
    runs-on: [self-hosted, k3s, homelab]
    outputs:
      image-tag: ${{ steps.vars.outputs.IMAGE_TAG }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout application repository
        uses: actions/checkout@v4

      - name: Set dynamic image tag
        id: vars
        run: |
          IMAGE_TAG=$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "üè∑Ô∏è Image tag: $IMAGE_TAG"

      - name: Install Python dependencies for testing
        run: |
          # Ensure Python is available
          if ! command -v python3 &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y python3 python3-pip python3-venv
          fi
          
          # Create and activate virtual environment
          python3 -m venv test-env
          source test-env/bin/activate
          
          # Install dependencies
          pip install --upgrade pip
          pip install fastapi uvicorn pytest httpx
          
          echo "‚úÖ Python environment ready"

      - name: Run application tests
        run: |
          source test-env/bin/activate
          
          # Create test file if it doesn't exist
          if [ ! -f "test_main.py" ]; then
            cat > test_main.py << 'EOF'
          import sys
          import os
          sys.path.append(os.path.join(os.path.dirname(__file__), 'app'))

          from fastapi.testclient import TestClient
          from main import app

          client = TestClient(app)

          def test_root():
              response = client.get("/")
              assert response.status_code == 200
              data = response.json()
              assert "message" in data
              assert "timestamp" in data
              assert "hostname" in data
              print("‚úÖ Root endpoint test passed")

          def test_ping():
              response = client.get("/ping")
              assert response.status_code == 200
              data = response.json()
              assert data["message"] == "pong"
              assert "timestamp" in data
              print("‚úÖ Ping endpoint test passed")

          def test_health():
              response = client.get("/health")
              assert response.status_code == 200
              data = response.json()
              assert data["status"] == "healthy"
              assert "timestamp" in data
              assert "hostname" in data
              print("‚úÖ Health endpoint test passed")

          def test_ready():
              response = client.get("/ready")
              assert response.status_code == 200
              data = response.json()
              assert data["status"] == "ready"
              print("‚úÖ Ready endpoint test passed")

          if __name__ == "__main__":
              test_root()
              test_ping()
              test_health()
              test_ready()
              print("üéâ All tests passed!")
          EOF
          fi
          
          # Run tests
          python test_main.py
          echo "‚úÖ Application tests completed successfully"

      - name: Build Docker image
        id: build
        run: |
          echo "üê≥ Building Docker image..."
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f "Dockerfile" ]; then
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim

          WORKDIR /app

          # Install system dependencies
          RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

          # Copy requirements and install Python dependencies
          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt

          # Copy application code
          COPY app/ ./app/

          # Create non-root user
          RUN useradd -m -u 1000 appuser && chown -R appuser /app
          USER appuser

          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
              CMD curl -f http://localhost:8080/health || exit 1

          # Expose port
          EXPOSE 8080

          # Run the application
          CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
          EOF
          fi
          
          # Build images
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest .
          
          echo "üìã Built images:"
          docker images | grep ${{ env.IMAGE_NAME }}

      - name: Test Docker image
        run: |
          # Ensure old container is removed if it exists
          docker rm -f test-fastapi || true
          echo "üß™ Testing Docker image..."
          
          # Run container in background
          docker run -d --name test-fastapi -p 8080:8080 \
            ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          
          # Wait for container to be fully running
          echo "‚è≥ Waiting 30 sec for container startup..."
          sleep 30
          
          # Check container status
          if ! docker ps | grep -q test-fastapi; then
            echo "‚ùå Container is not running"
            echo "=== Container Status ==="
            docker ps -a | grep test-fastapi
            echo "=== Container Logs ==="
            docker logs test-fastapi
            docker rm test-fastapi
            exit 1
          fi
          
          # Wait for application to be ready with better logging
          echo "‚è≥ Waiting for FastAPI application to be ready..."
          for i in {1..60}; do
            # Check if Uvicorn is running
            if docker logs test-fastapi 2>&1 | grep -q "Uvicorn running on\|Application startup complete"; then
              echo "‚úÖ FastAPI application started"
              break
            fi
            
            # Show current logs every 10 seconds
            if [ $((i % 10)) -eq 0 ]; then
              echo "=== Current Container Logs (attempt $i/60) ==="
              docker logs test-fastapi 2>&1 | tail -10
            fi
            
            if [ $i -eq 60 ]; then
              echo "‚ùå FastAPI application failed to start within 2 minutes"
              echo "=== Full Container Logs ==="
              docker logs test-fastapi
              docker stop test-fastapi && docker rm test-fastapi
              exit 1
            fi
            sleep 2
          done
          
          # Additional wait for the service to be fully ready
          echo "‚è≥ Allowing additional time for service initialization..."
          sleep 10
          
          # Check if port is actually listening
          echo "üîç Checking if port 8080 is listening..."
          netstat -tlnp | grep :8080 || echo "Port 8080 not found in netstat"
          ss -tlnp | grep :8080 || echo "Port 8080 not found in ss"
          echo "üîç Checking if port 8080 is listening..."
          # Convert 8080 to hex: 8080 = 0x1F90
          grep -q ":1F90" /proc/net/tcp && echo "‚úÖ Port 8080 found in /proc/net/tcp" || echo "‚ùå Port 8080 not found"
          
          # Test health endpoint with detailed debugging
          echo "üè• Testing health endpoint..."
          for i in {1..15}; do
            echo "Health check attempt $i/15..."
            
            # Try curl with verbose output on first and last attempts
            if [ $i -eq 1 ] || [ $i -eq 15 ]; then
              curl -v --max-time 15 "http://localhost:8080/health" 2>&1 || true
            else
              curl -f --max-time 10 "http://localhost:8080/health" 2>/dev/null
            fi
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Health check passed on attempt $i"
              break
            fi
            
            if [ $i -eq 15 ]; then
              echo "‚ùå Health check failed after 15 attempts"
              echo "=== Debug Information ==="
              echo "Container status:"
              docker ps | grep test-fastapi
              echo "Container logs:"
              docker logs test-fastapi
              echo "Container processes:"
              docker exec test-fastapi ps aux 2>/dev/null || echo "Could not list processes"
              echo "Container network:"
              docker exec test-fastapi netstat -tlnp 2>/dev/null || echo "Could not list ports"
              
              # Try direct container connection
              CONTAINER_IP=$(docker inspect test-fastapi --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
              if [ -n "$CONTAINER_IP" ]; then
                echo "Trying direct container IP: $CONTAINER_IP"
                curl -v --max-time 10 "http://$CONTAINER_IP:8080/health" 2>&1 || echo "Direct connection failed"
              fi
              
              docker stop test-fastapi && docker rm test-fastapi
              exit 1
            fi
            
            echo "Retrying in 4 seconds..."
            sleep 4
          done
          
          # Test a few more endpoints if health passed
          echo "üß™ Testing additional endpoints..."
          curl -f --max-time 10 "http://localhost:8080/health" || echo "Health endpoint failed" 
          curl -f --max-time 10 "http://localhost:8080/" || echo "Root endpoint failed"
          curl -f --max-time 10 "http://localhost:8080/ping" || echo "Ping endpoint failed"
          echo "üîç Verifying container is still running..."
          if ! docker ps | grep -q test-fastapi; then
            echo "‚ùå Container crashed after startup!"
            echo "=== Container Status ==="
            docker ps -a | grep test-fastapi
            echo "=== Container Logs ==="
            docker logs test-fastapi
            exit 1
         fi
          
          # Cleanup
          echo "üßπ Cleaning up test container..."
          docker stop test-fastapi && docker rm test-fastapi
          echo "‚úÖ Docker image test completed successfully"
      
      - name: Push Docker images
        run: |
          echo "üì§ Pushing images to internal registry..."
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest
          
          echo "‚úÖ Images pushed successfully!"

      - name: Verify registry push
        run: |
          echo "üîç Verifying images in registry..."
          curl -s http://${{ env.REGISTRY_URL }}/v2/${{ env.IMAGE_NAME }}/tags/list | jq . || echo "Registry verification failed"

  # üöÄ CD Pipeline: Update Deployment Repository
  cd-pipeline:
    needs: ci-pipeline
    runs-on: [self-hosted, k3s, homelab]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout deployment repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.DEPLOY_REPO }}
          token: ${{ secrets.GH_TOKEN }}
          path: deploy-repo

      - name: Install required tools
        run: |
          # Install yq for YAML processing
          if ! command -v yq &> /dev/null; then
            sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
            sudo chmod +x /usr/local/bin/yq
          fi
          
          # Install kubectl if missing
          if ! command -v kubectl &> /dev/null; then
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          
          # Install ArgoCD CLI if missing
          if ! command -v argocd &> /dev/null; then
            ARGOCD_VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep tag_name | cut -d '"' -f 4)
            curl -sSL -o argocd "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"
            chmod +x argocd
            sudo mv argocd /usr/local/bin/
          fi
          
          echo "‚úÖ Tools installed:"
          yq --version
          kubectl version --client
          argocd version --client

      - name: Update Helm values with new image
        run: |
          cd deploy-repo
          
          # Verify image exists in registry before updating
          echo "üîç Verifying image exists in registry..."
          for i in {1..10}; do
            if curl -f -s "http://${{ env.REGISTRY_URL }}/v2/${{ env.IMAGE_NAME }}/manifests/${{ needs.ci-pipeline.outputs.image-tag }}" >/dev/null; then
              echo "‚úÖ Image verified in registry"
              break
            else
              echo "Image not yet available in registry, waiting... ($i/10)"
              sleep 10
              if [ $i -eq 10 ]; then
                echo "‚ùå Image not found in registry after 100 seconds"
                exit 1
              fi
            fi
          done
          
          echo "üìÑ Current values.yaml:"
          cat charts/fastapi-ml/values.yaml
          
          echo "üìù Updating image tag to: ${{ needs.ci-pipeline.outputs.image-tag }}"
          yq e '.image.tag = "${{ needs.ci-pipeline.outputs.image-tag }}"' -i charts/fastapi-ml/values.yaml
          
          echo "üìÑ Updated values.yaml:"
          cat charts/fastapi-ml/values.yaml
          
          UPDATED_TAG=$(yq e '.image.tag' charts/fastapi-ml/values.yaml)
          echo "üìã Verification - image.tag is now: $UPDATED_TAG"
          
          if [ "$UPDATED_TAG" != "${{ needs.ci-pipeline.outputs.image-tag }}" ]; then
            echo "‚ùå Image tag update failed!"
            exit 1
          fi

      - name: Commit and push deployment changes
        run: |
          cd deploy-repo
          
          # Configure git
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Check if there are changes
          if git diff --quiet charts/fastapi-ml/values.yaml; then
            echo "‚ÑπÔ∏è No changes to commit"
          else
            # Commit and push changes
            git add charts/fastapi-ml/values.yaml
            git commit -m "chore: update fastapi-ml-app image to ${{ needs.ci-pipeline.outputs.image-tag }}

            - Updated by: ${{ github.actor }}
            - Source commit: ${{ github.sha }}
            - Build time: $(date -u)"
            
            git push https://x-access-token:${{ secrets.GH_TOKEN }}@github.com/SandipJaiswal/fastapi-ml-deploy.git HEAD:main
            
            echo "‚úÖ Deployment repository updated"
            
            # Wait for Git changes to propagate
            echo "‚è≥ Waiting for Git changes to propagate..."
            sleep 20
          fi

      - name: Trigger ArgoCD sync and wait
        run: |
          echo "üîÑ Triggering ArgoCD sync..."
          
          # Login to ArgoCD
          argocd login ${{ env.ARGOCD_SERVER }} --username admin \
            --password "${{ secrets.ARGOCD_PASSWORD }}" --plaintext
          
          # Check current app status
          echo "üìä Current ArgoCD application status:"
          argocd app get fastapi-ml || echo "Application not found or not accessible"
          
          # Force sync the application
          echo "üîÑ Forcing sync..."
          argocd app sync fastapi-ml --force --timeout 300
          
          # Wait for sync to complete
          echo "‚è≥ Waiting for sync completion..."
          argocd app wait fastapi-ml --timeout 600 --health
          
          echo "‚úÖ ArgoCD sync completed"

      - name: Wait and verify deployment
        run: |
          echo "‚è≥ Waiting for Kubernetes deployment..."
          
          # Wait for namespace to exist
          for i in {1..20}; do
            if kubectl get namespace fastapi-ml >/dev/null 2>&1; then
              echo "‚úÖ Namespace fastapi-ml exists"
              break
            fi
            echo "Waiting for namespace... ($i/20)"
            sleep 10
          done
          
          # Wait for deployment to exist and be ready
          echo "üì¶ Waiting for deployment..."
          kubectl wait --for=condition=available --timeout=600s deployment/fastapi-ml -n fastapi-ml
          
          # Check pod status
          echo "üîç Pod status:"
          kubectl get pods -n fastapi-ml -o wide
          
          # Verify the new image is deployed
          DEPLOYED_IMAGE=$(kubectl get deployment fastapi-ml -n fastapi-ml -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "üñºÔ∏è Deployed image: $DEPLOYED_IMAGE"
          
          if [[ "$DEPLOYED_IMAGE" == *"${{ needs.ci-pipeline.outputs.image-tag }}"* ]]; then
            echo "‚úÖ Correct image version deployed"
          else
            echo "‚ùå Wrong image version deployed"
            echo "Expected: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ needs.ci-pipeline.outputs.image-tag }}"
            echo "Actual: $DEPLOYED_IMAGE"
            exit 1
          fi

      - name: Test service connectivity
        run: |
          echo "üåê Testing service connectivity..."
          
          # Get service information
          kubectl get svc fastapi-ml -n fastapi-ml -o wide
          
          # Wait for LoadBalancer IP
          echo "‚è≥ Waiting for LoadBalancer IP..."
          for i in {1..30}; do
            SERVICE_IP=$(kubectl get svc fastapi-ml -n fastapi-ml -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$SERVICE_IP" ] && [ "$SERVICE_IP" != "null" ] && [ "$SERVICE_IP" != "<pending>" ]; then
              echo "‚úÖ Service available at: $SERVICE_IP"
              
              # Test the service on port 8080 (external port)
              echo "üß™ Testing service health check on port 8080..."
              for j in {1..10}; do
                if curl -f --max-time 15 "http://$SERVICE_IP:8080/health"; then
                  echo "üéâ Service health check passed on port 8080!"
                  break
                elif [ $j -eq 10 ]; then
                  echo "‚ùå Health check failed on port 8080"
                  # Try direct pod access for debugging
                  echo "üîç Debugging - trying direct pod access..."
                  POD_NAME=$(kubectl get pods -n fastapi-ml -l app=fastapi-ml -o jsonpath='{.items[0].metadata.name}')
                  if [ -n "$POD_NAME" ]; then
                    echo "Testing direct pod access on port 8080..."
                    kubectl port-forward pod/$POD_NAME 8080:8080 -n fastapi-ml &
                    PF_PID=$!
                    sleep 5
                    curl -f --max-time 10 "http://localhost:8080/health" || echo "Direct pod access failed"
                    kill $PF_PID || true
                  fi
                  exit 1
                else
                  echo "Health check attempt $j/10 failed, waiting..."
                  sleep 10
                fi
              done
              break
            fi
            echo "Waiting for LoadBalancer IP... ($i/30)"
            sleep 10
          done
          
          if [ -z "$SERVICE_IP" ] || [ "$SERVICE_IP" = "null" ] || [ "$SERVICE_IP" = "<pending>" ]; then
            echo "‚ö†Ô∏è LoadBalancer IP not assigned. Checking service type..."
            kubectl describe svc fastapi-ml -n fastapi-ml
            
            # Try NodePort or ClusterIP access as fallback
            SERVICE_TYPE=$(kubectl get svc fastapi-ml -n fastapi-ml -o jsonpath='{.spec.type}')
            echo "Service type: $SERVICE_TYPE"
            
            if [ "$SERVICE_TYPE" = "NodePort" ]; then
              NODE_PORT=$(kubectl get svc fastapi-ml -n fastapi-ml -o jsonpath='{.spec.ports[0].nodePort}')
              NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
              echo "Trying NodePort access: $NODE_IP:$NODE_PORT"
              curl -f --max-time 10 "http://$NODE_IP:$NODE_PORT/health" || echo "NodePort access failed"
            fi
          fi

  # üìä Summary Job
  summary:
    needs: [ci-pipeline, cd-pipeline]
    runs-on: [self-hosted, k3s, homelab]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "üìä CI/CD Pipeline Summary"
          echo "========================="
          echo "üî® CI Status: ${{ needs.ci-pipeline.result }}"
          echo "üöÄ CD Status: ${{ needs.cd-pipeline.result }}"
          echo "üè∑Ô∏è Image Tag: ${{ needs.ci-pipeline.outputs.image-tag }}"
          echo "üì¶ Registry: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}"
          echo "üéØ ArgoCD: http://${{ env.ARGOCD_SERVER }}"
          echo
          
          if [ "${{ needs.cd-pipeline.result }}" == "success" ]; then
            echo "üéâ Deployment completed successfully!"
            echo "‚úÖ Your FastAPI app should be running in the cluster"
            echo "üîç Check: kubectl get pods -n fastapi-ml"
            echo "üåê Service: kubectl get svc fastapi-ml -n fastapi-ml"
          else
            echo "‚ùå Deployment encountered issues"
            echo "üîß Check ArgoCD dashboard: http://${{ env.ARGOCD_SERVER }}"
            echo "üîç Debug commands:"
            echo "  kubectl get pods -n fastapi-ml"
            echo "  kubectl describe deployment fastapi-ml -n fastapi-ml"
            echo "  kubectl logs -l app=fastapi-ml -n fastapi-ml"
          fi
