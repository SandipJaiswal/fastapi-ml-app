name: CI/CD FastAPI ML App - Multi-Repo GitOps

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY_URL: "192.168.0.200:5000"
  IMAGE_NAME: "fastapi-ml-app"
  DEPLOY_REPO: "SandipJaiswal/fastapi-ml-deploy"
  ARGOCD_SERVER: "192.168.0.201"

jobs:
  # 🧪 CI Pipeline: Test and Build
  ci-pipeline:
    runs-on: [self-hosted, k3s, homelab]
    outputs:
      image-tag: ${{ steps.vars.outputs.IMAGE_TAG }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout application repository
        uses: actions/checkout@v4

      - name: Set dynamic image tag
        id: vars
        run: |
          IMAGE_TAG=$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "🏷️ Image tag: $IMAGE_TAG"

      - name: Install Python dependencies for testing
        run: |
          # Ensure Python is available
          if ! command -v python3 &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y python3 python3-pip python3-venv
          fi
          
          # Create and activate virtual environment
          python3 -m venv test-env
          source test-env/bin/activate
          
          # Install dependencies
          pip install --upgrade pip
          pip install fastapi uvicorn pytest httpx
          
          echo "✅ Python environment ready"

      - name: Run application tests
        run: |
          source test-env/bin/activate
          
          # Create test file if it doesn't exist
          if [ ! -f "test_main.py" ]; then
            cat > test_main.py << 'EOF'
          import sys
          import os
          sys.path.append(os.path.join(os.path.dirname(__file__), 'app'))

          from fastapi.testclient import TestClient
          from main import app

          client = TestClient(app)

          def test_root():
              response = client.get("/")
              assert response.status_code == 200
              data = response.json()
              assert "message" in data
              assert "timestamp" in data
              assert "hostname" in data
              print("✅ Root endpoint test passed")

          def test_ping():
              response = client.get("/ping")
              assert response.status_code == 200
              data = response.json()
              assert data["message"] == "pong"
              assert "timestamp" in data
              print("✅ Ping endpoint test passed")

          def test_health():
              response = client.get("/health")
              assert response.status_code == 200
              data = response.json()
              assert data["status"] == "healthy"
              assert "timestamp" in data
              assert "hostname" in data
              print("✅ Health endpoint test passed")

          def test_ready():
              response = client.get("/ready")
              assert response.status_code == 200
              data = response.json()
              assert data["status"] == "ready"
              print("✅ Ready endpoint test passed")

          if __name__ == "__main__":
              test_root()
              test_ping()
              test_health()
              test_ready()
              print("🎉 All tests passed!")
          EOF
          fi
          
          # Run tests
          python test_main.py
          echo "✅ Application tests completed successfully"

      - name: Build Docker image
        id: build
        run: |
          echo "🐳 Building Docker image..."
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f "Dockerfile" ]; then
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim

          WORKDIR /app

          # Install system dependencies
          RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

          # Copy requirements and install Python dependencies
          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt

          # Copy application code
          COPY app/ ./app/

          # Create non-root user
          RUN useradd -m -u 1000 appuser && chown -R appuser /app
          USER appuser

          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
              CMD curl -f http://localhost:8000/health || exit 1

          # Expose port
          EXPOSE 8000

          # Run the application
          CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
          EOF
          fi
          
          # Build images
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest .
          
          echo "📋 Built images:"
          docker images | grep ${{ env.IMAGE_NAME }}

      - name: Test Docker image (Debug)
        run: |
          # Ensure old container is removed if it exists
          docker rm -f test-fastapi || true
          echo "🧪 Testing Docker image with debugging..."
          
          # Run container in background
          docker run -d --name test-fastapi -p 8001:8000 \
            ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          
          # Wait for startup
          echo "⏳ Waiting 45 seconds for container startup..."
          sleep 45
          
          # Debug information
          echo "🔍 Debug Information:"
          echo "=== Container Status ==="
          docker ps -a | grep test-fastapi
          
          echo "=== Container Logs ==="
          docker logs test-fastapi
          
          echo "=== Port Information ==="
          docker port test-fastapi
          
          echo "=== Network Information ==="
          netstat -tlnp | grep :8001 || echo "Port 8001 not listening"
          
          echo "=== Process Information ==="
          ss -tulpn | grep :8001 || echo "No process on 8001"
          
          # Try connecting directly to container IP
          CONTAINER_IP=$(docker inspect test-fastapi | jq -r '.[0].NetworkSettings.IPAddress')
          echo "=== Container IP: $CONTAINER_IP ==="
          
          if [ -n "$CONTAINER_IP" ] && [ "$CONTAINER_IP" != "null" ]; then
            echo "Testing direct container connection..."
            curl -f --max-time 10 "http://$CONTAINER_IP:8000/health" || echo "Direct connection failed"
          fi
          
          # Try localhost connection
          echo "Testing localhost connection..."
          curl -v --max-time 10 "http://localhost:8001/health" || echo "Localhost connection failed"
          
          # Cleanup
          docker stop test-fastapi && docker rm test-fastapi
      
      - name: Push Docker images
        run: |
          echo "📤 Pushing images to internal registry..."
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest
          
          echo "✅ Images pushed successfully!"

      - name: Verify registry push
        run: |
          echo "🔍 Verifying images in registry..."
          curl -s http://${{ env.REGISTRY_URL }}/v2/${{ env.IMAGE_NAME }}/tags/list | jq . || echo "Registry verification failed"

  # 🚀 CD Pipeline: Update Deployment Repository
  cd-pipeline:
    needs: ci-pipeline
    runs-on: [self-hosted, k3s, homelab]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout deployment repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.DEPLOY_REPO }}
          token: ${{ secrets.GH_TOKEN }}
          path: deploy-repo

      - name: Install yq for YAML processing
        run: |
          if ! command -v yq &> /dev/null; then
            sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
            sudo chmod +x /usr/local/bin/yq
          fi
          yq --version

      - name: Update Helm values with new image
        run: |
          cd deploy-repo
          
          # Verify image exists in registry before updating
          echo "🔍 Verifying image exists in registry..."
          for i in {1..5}; do
            if curl -f -s "http://${{ env.REGISTRY_URL }}/v2/${{ env.IMAGE_NAME }}/manifests/${{ needs.ci-pipeline.outputs.image-tag }}" >/dev/null; then
              echo "✅ Image verified in registry"
              break
            else
              echo "Image not yet available in registry, waiting... ($i/5)"
              sleep 10
              if [ $i -eq 5 ]; then
                echo "❌ Image not found in registry after 50 seconds"
                exit 1
              fi
            fi
          done
          
          echo "📝 Current values.yaml:"
          cat charts/fastapi-ml/values.yaml
          
          echo "🔄 Updating image tag to: ${{ needs.ci-pipeline.outputs.image-tag }}"
          yq e '.image.tag = "${{ needs.ci-pipeline.outputs.image-tag }}"' -i charts/fastapi-ml/values.yaml
          
          echo "📝 Updated values.yaml:"
          cat charts/fastapi-ml/values.yaml

      - name: Commit and push deployment changes
        run: |
          cd deploy-repo
          
          # Configure git
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Check if there are changes
          if git diff --quiet charts/fastapi-ml/values.yaml; then
            echo "ℹ️ No changes to commit"
          else
            # Commit and push changes
            git add charts/fastapi-ml/values.yaml
            git commit -m "chore: update fastapi-ml-app image to ${{ needs.ci-pipeline.outputs.image-tag }}

            - Updated by: ${{ github.actor }}
            - Source commit: ${{ github.sha }}
            - Build time: $(date -u)"
            
            git push https://x-access-token:${{ secrets.GH_TOKEN }}@github.com/SandipJaiswal/fastapi-ml-deploy.git HEAD:main
            
            echo "✅ Deployment repository updated"
          fi


      - name: Install ArgoCD CLI if missing
        run: |
         if command -v argocd >/dev/null 2>&1; then
           echo "✅ ArgoCD CLI already installed at $(command -v argocd)"
           argocd version --client
         else
           echo "📥 Installing ArgoCD CLI..."
           ARGOCD_VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep tag_name | cut -d '"' -f 4)
           curl -sSL -o argocd "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"
           chmod +x argocd
           mkdir -p $HOME/bin
           mv argocd $HOME/bin/
           echo "$HOME/bin" >> $GITHUB_PATH
           echo "✅ ArgoCD CLI installed at $HOME/bin/argocd"
         fi 

      - name: Verify ArgoCD CLI & login
        run: |
          argocd version --client
          #argocd login ${{ env.ARGOCD_SERVER }} --username admin --password ${{ secrets.ARGOCD_PASSWORD }} --insecure


      - name: Ensure kubectl is installed
        run: |
          if command -v kubectl >/dev/null 2>&1; then
            echo "✅ kubectl already installed at $(command -v kubectl)"
            kubectl version --client
          else
            echo "📥 Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            mkdir -p $HOME/bin
            mv kubectl $HOME/bin/
            echo "$HOME/bin" >> $GITHUB_PATH
            #sudo mv kubectl /usr/local/bin/
            echo "✅ kubectl installed at $(command -v kubectl)"
            kubectl version --client
          fi

      - name: Trigger ArgoCD sync
        run: |
          echo "🔄 Triggering ArgoCD sync..."
          
          # Wait for Git changes to propagate
          sleep 15
          
          # Method 1: Try ArgoCD CLI first
          if command -v argocd &> /dev/null; then
            echo "Using ArgoCD CLI..."
            argocd login ${{ env.ARGOCD_SERVER }} --username admin \
              --password "${{ secrets.ARGOCD_PASSWORD }}" --insecure || true
            argocd app sync fastapi-ml --force || echo "CLI sync failed"
            argocd app wait fastapi-ml --timeout 300 || echo "CLI wait failed"
          else
            echo "ArgoCD CLI not available, using kubectl..."
            
            # Method 2: Use kubectl to patch ArgoCD application
            kubectl patch application fastapi-ml -n argocd --type merge \
              -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"HEAD"}}}' || \
              echo "⚠️ kubectl patch failed, ArgoCD will auto-sync eventually"
          fi
          
          echo "✅ ArgoCD sync triggered"

      - name: Wait and verify deployment
        run: |
          echo "⏳ Waiting for ArgoCD to process changes..."
          
          # Wait for ArgoCD application to exist and be synced
          for i in {1..20}; do
            if kubectl get application fastapi-ml -n argocd >/dev/null 2>&1; then
              APP_STATUS=$(kubectl get application fastapi-ml -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
              echo "ArgoCD sync status: $APP_STATUS"
              
              if [ "$APP_STATUS" = "Synced" ] || [ "$APP_STATUS" = "OutOfSync" ]; then
                echo "✅ ArgoCD application is processing"
                break
              fi
            fi
            
            echo "Waiting for ArgoCD... ($i/20)"
            sleep 15
          done
          
          # Wait for namespace creation
          echo "🏗️ Waiting for namespace creation..."
          for i in {1..10}; do
            if kubectl get namespace fastapi-ml >/dev/null 2>&1; then
              echo "✅ Namespace fastapi-ml exists"
              break
            fi
            echo "Waiting for namespace... ($i/10)"
            sleep 10
          done
          
          # Wait for deployment with better error handling
          if kubectl get deployment fastapi-ml -n fastapi-ml >/dev/null 2>&1; then
            echo "📊 Deployment found, waiting for rollout..."
            kubectl rollout status deployment/fastapi-ml -n fastapi-ml --timeout=600s || {
              echo "❌ Deployment rollout failed, showing debug info:"
              kubectl get pods -n fastapi-ml
              kubectl describe deployment fastapi-ml -n fastapi-ml
              kubectl get events -n fastapi-ml --sort-by='.lastTimestamp' | tail -10
              exit 1
            }
            
            # Wait for LoadBalancer IP with retries
            echo "🌐 Waiting for LoadBalancer IP..."
            for i in {1..12}; do
              SERVICE_IP=$(kubectl get svc fastapi-ml -n fastapi-ml -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
              if [ -n "$SERVICE_IP" ] && [ "$SERVICE_IP" != "null" ]; then
                echo "✅ Service available at: http://$SERVICE_IP"
                
                # Test service with retries
                for j in {1..6}; do
                  if curl -f --max-time 10 "http://$SERVICE_IP/health"; then
                    echo "🎉 Service health check passed!"
                    break
                  else
                    echo "Health check attempt $j/6 failed, waiting..."
                    sleep 10
                  fi
                done
                break
              fi
              echo "Waiting for LoadBalancer IP... ($i/12)"
              sleep 10
            done
          else
            echo "❌ Deployment not found after waiting. Checking ArgoCD status:"
            kubectl get application fastapi-ml -n argocd -o yaml || echo "ArgoCD application not found"
            kubectl get events -n argocd --sort-by='.lastTimestamp' | grep fastapi || echo "No ArgoCD events found"
            exit 1
          fi

  # 📊 Summary Job
  summary:
    needs: [ci-pipeline, cd-pipeline]
    runs-on: [self-hosted, k3s, homelab]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "📊 CI/CD Pipeline Summary"
          echo "========================="
          echo "🔨 CI Status: ${{ needs.ci-pipeline.result }}"
          echo "🚀 CD Status: ${{ needs.cd-pipeline.result }}"
          echo "🏷️ Image Tag: ${{ needs.ci-pipeline.outputs.image-tag }}"
          echo "📦 Registry: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}"
          echo "🎯 ArgoCD: http://${{ env.ARGOCD_SERVER }}"
          echo
          
          if [ "${{ needs.cd-pipeline.result }}" == "success" ]; then
            echo "🎉 Deployment completed successfully!"
            echo "✅ Your FastAPI app should be running in the cluster"
            echo "🔍 Check: kubectl get pods -n fastapi-ml"
          else
            echo "❌ Deployment encountered issues"
            echo "🔧 Check ArgoCD dashboard: http://${{ env.ARGOCD_SERVER }}"
          fi
