name: CI/CD FastAPI ML App - K3s Self-Hosted

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  REGISTRY_URL: "192.168.0.200:5000"
  IMAGE_NAME: "fastapi-ml-app"
  ARGOCD_SERVER: "192.168.0.201"

jobs:
  test:
    runs-on: [self-hosted, k3s, homelab]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        run: |
          if ! command -v python3 &> /dev/null; then
            sudo apt-get update
            sudo apt-get install -y python3 python3-pip python3-venv
          fi
          python3 -m venv venv
          source venv/bin/activate
          python -m pip install --upgrade pip

      - name: Install dependencies
        run: |
          source venv/bin/activate
          pip install fastapi uvicorn pytest httpx

      - name: Run tests
        run: |
          source venv/bin/activate
          if [ ! -f "test_main.py" ]; then
            cat > test_main.py << 'EOF'
          from fastapi.testclient import TestClient
          from app.main import app

          client = TestClient(app)

          def test_root():
              response = client.get("/")
              assert response.status_code == 200
              data = response.json()
              assert data["message"] == "FastAPI is running!" 

          def test_ping():
              response = client.get("/ping")
              assert response.status_code == 200
              data = response.json()
              assert data["message"] == "pong"
          EOF
          fi
          pytest test_main.py -v

  build-and-push:
    needs: test
    runs-on: [self-hosted, k3s, homelab]
    outputs:
      image-tag: ${{ steps.vars.outputs.IMAGE_TAG }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set dynamic image tag
        id: vars
        run: |
          IMAGE_TAG=$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Create Dockerfile if not exists
        run: |
          if [ ! -f "Dockerfile" ]; then
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim

          WORKDIR /app

          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt

          COPY . .

          EXPOSE 8000

          CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
          EOF
          fi

      - name: Create requirements.txt if not exists
        run: |
          if [ ! -f "requirements.txt" ]; then
            cat > requirements.txt << 'EOF'
          fastapi==0.104.1
          uvicorn[standard]==0.24.0
          EOF
          fi

      - name: Build Docker image
        run: |
          echo "üê≥ Building Docker image..."
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest .
          echo "üìã Built images:"
          docker images | grep ${{ env.IMAGE_NAME }}

      - name: Test Docker image
        run: |
          echo "üß™ Testing Docker image..."
          docker rm -f test-app || true
          docker run -d --name test-app ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

          MAX_RETRIES=30
          RETRY_COUNT=0
          until docker exec test-app curl -s http://127.0.0.1:8000/health > /dev/null; do
            RETRY_COUNT=$((RETRY_COUNT+1))
            if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
              echo "‚ùå Container failed to start in time"
              docker logs test-app
              docker stop test-app
              docker rm test-app
              exit 1
            fi
            sleep 2
          done
          echo "‚úÖ Container is ready"
          docker exec test-app curl -f http://127.0.0.1:8000/health
          docker exec test-app curl -f http://127.0.0.1:8000/ping

          docker stop test-app
          docker rm test-app

          echo "‚úÖ Docker image tests passed!"

      - name: Push Docker image to registry
        run: |
          echo "üì§ Pushing images to registry..."
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest
          echo "‚úÖ Images pushed successfully!"

      - name: Verify registry push
        run: |
          echo "üîç Verifying image in registry..."
          curl -s http://${{ env.REGISTRY_URL }}/v2/${{ env.IMAGE_NAME }}/tags/list || echo "Registry check failed"

  deploy:
    needs: [test, build-and-push]
    runs-on: [self-hosted, k3s, homelab]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set image tag from build job
        run: |
          echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_ENV

      - name: Update ArgoCD application
        working-directory: ../fastapi-ml-deploy/charts/fastapi-ml
        run: |
          echo "üîÑ Triggering ArgoCD deployment..."
          if command -v yq &> /dev/null; then
            yq e '.image.tag = "${{ env.IMAGE_TAG }}"' -i values.yaml
            echo "Updated image tag to: ${{ env.IMAGE_TAG }}"
          fi
          ARGOCD_TOKEN="${{ secrets.ARGOCD_TOKEN }}"
          if [ -n "$ARGOCD_TOKEN" ]; then
            curl -X POST \
              -H "Authorization: Bearer $ARGOCD_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{
                    \"revision\": \"HEAD\",
                    \"prune\": true,
                    \"dryRun\": false,
                    \"strategy\": {
                      \"hook\": {
                        \"force\": true
                      }
                    }
                  }" \
              "http://${{ env.ARGOCD_SERVER }}/api/v1/applications/fastapi-ml/sync"
          else
            echo "‚ö†Ô∏è ARGOCD_TOKEN not set, skipping ArgoCD sync"
          fi

      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for deployment to be ready..."
          sleep 30
          if kubectl get deployment fastapi-ml -n fastapi-ml >/dev/null 2>&1; then
            kubectl rollout status deployment/fastapi-ml -n fastapi-ml --timeout=300s
            echo "‚úÖ Deployment rolled out successfully!"
          else
            echo "‚ö†Ô∏è Deployment not found, may still be creating..."
          fi

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          kubectl get pods -n fastapi-ml -l app=fastapi-ml
          kubectl get svc -n fastapi-ml
          SERVICE_IP=$(kubectl get svc fastapi-ml -n fastapi-ml -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -n "$SERVICE_IP" ]; then
            echo "üåê Testing service at: http://$SERVICE_IP"
            sleep 10
            curl -f "http://$SERVICE_IP/" || echo "Service not yet ready"
          fi

      - name: Deployment summary
        run: |
          echo "üìä Deployment Summary:"
          echo "  Image: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "  Namespace: fastapi-ml"
          echo "  ArgoCD: http://${{ env.ARGOCD_SERVER }}"
          echo "  Registry: http://${{ env.REGISTRY_URL }}"

  notify:
    needs: [test, build-and-push, deploy]
    runs-on: [self-hosted, k3s, homelab]
    if: always()
    steps:
      - name: Deployment notification
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "üéâ Deployment successful!"
            echo "‚úÖ Tests: ${{ needs.test.result }}"
            echo "‚úÖ Build: ${{ needs.build-and-push.result }}"
            echo "‚úÖ Deploy: ${{ needs.deploy.result }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Tests: ${{ needs.test.result }}"
            echo "Build: ${{ needs.build-and-push.result }}"
            echo "Deploy: ${{ needs.deploy.result }}"