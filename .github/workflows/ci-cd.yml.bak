name: CI/CD FastAPI ML App - Multi-Repo GitOps

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY_URL: "192.168.0.200:5000"
  IMAGE_NAME: "fastapi-ml-app"
  DEPLOY_REPO: "SandipJaiswal/fastapi-ml-deploy"
  ARGOCD_SERVER: "192.168.0.201"

jobs:
  # ğŸ§ª CI Pipeline: Test and Build
  ci-pipeline:
    runs-on: [self-hosted, k3s, homelab]
    outputs:
      image-tag: ${{ steps.vars.outputs.IMAGE_TAG }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout application repository
        uses: actions/checkout@v4

      - name: Set dynamic image tag
        id: vars
        run: |
          IMAGE_TAG=$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "ğŸ·ï¸ Image tag: $IMAGE_TAG"

      - name: Install Python dependencies for testing
        run: |
          # Ensure Python is available
          if ! command -v python3 &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y python3 python3-pip python3-venv
          fi
          
          # Create and activate virtual environment
          python3 -m venv test-env
          source test-env/bin/activate
          
          # Install dependencies
          pip install --upgrade pip
          pip install fastapi uvicorn pytest httpx
          
          echo "âœ… Python environment ready"

      - name: Run application tests
        run: |
          source test-env/bin/activate
          
          # Create test file if it doesn't exist
          if [ ! -f "test_main.py" ]; then
            cat > test_main.py << 'EOF'
          import sys
          import os
          sys.path.append(os.path.join(os.path.dirname(__file__), 'app'))

          from fastapi.testclient import TestClient
          from main import app

          client = TestClient(app)

          def test_root():
              response = client.get("/")
              assert response.status_code == 200
              data = response.json()
              assert "message" in data
              print("âœ… Root endpoint test passed")

          def test_ping():
              response = client.get("/ping")
              assert response.status_code == 200
              assert response.json() == {"message": "pong"}
              print("âœ… Ping endpoint test passed")

          def test_health():
              response = client.get("/health")
              assert response.status_code == 200
              data = response.json()
              assert data["status"] == "healthy"
              print("âœ… Health endpoint test passed")

          if __name__ == "__main__":
              test_root()
              test_ping()
              test_health()
              print("ğŸ‰ All tests passed!")
          EOF
          fi
          
          # Run tests
          python test_main.py
          echo "âœ… Application tests completed successfully"

      - name: Build Docker image
        id: build
        run: |
          echo "ğŸ³ Building Docker image..."
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f "Dockerfile" ]; then
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim

          WORKDIR /app

          # Install system dependencies
          RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

          # Copy requirements and install Python dependencies
          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt

          # Copy application code
          COPY app/ ./app/

          # Create non-root user
          RUN useradd -m -u 1000 appuser && chown -R appuser /app
          USER appuser

          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
              CMD curl -f http://localhost:8000/health || exit 1

          # Expose port
          EXPOSE 8000

          # Run the application
          CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
          EOF
          fi
          
          # Build images
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .
          docker build -t ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest .
          
          echo "ğŸ“‹ Built images:"
          docker images | grep ${{ env.IMAGE_NAME }}

      - name: Test Docker image
        run: |
          echo "ğŸ§ª Testing Docker image..."
          
          # Run container in background
          docker run -d --name test-fastapi -p 8001:8000 \
            ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          
          # Wait for container to start
          sleep 15
          
          # Test endpoints
          echo "Testing root endpoint..."
          curl -f http://localhost:8001/ || (docker logs test-fastapi && exit 1)
          
          echo "Testing ping endpoint..."
          curl -f http://localhost:8001/ping || (docker logs test-fastapi && exit 1)
          
          echo "Testing health endpoint..."
          curl -f http://localhost:8001/health || (docker logs test-fastapi && exit 1)
          
          # Cleanup
          docker stop test-fastapi && docker rm test-fastapi
          
          echo "âœ… Docker image tests passed!"

      - name: Push Docker images
        run: |
          echo "ğŸ“¤ Pushing images to internal registry..."
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest
          
          echo "âœ… Images pushed successfully!"

      - name: Verify registry push
        run: |
          echo "ğŸ” Verifying images in registry..."
          curl -s http://${{ env.REGISTRY_URL }}/v2/${{ env.IMAGE_NAME }}/tags/list | jq . || echo "Registry verification failed"

  # ğŸš€ CD Pipeline: Update Deployment Repository
  cd-pipeline:
    needs: ci-pipeline
    runs-on: [self-hosted, k3s, homelab]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout deployment repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.DEPLOY_REPO }}
          token: ${{ secrets.GITHUB_TOKEN }}
          path: deploy-repo

      - name: Install yq for YAML processing
        run: |
          if ! command -v yq &> /dev/null; then
            sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
            sudo chmod +x /usr/local/bin/yq
          fi
          yq --version

      - name: Update Helm values with new image
        run: |
          cd deploy-repo
          
          echo "ğŸ“ Current values.yaml:"
          cat charts/fastapi-ml/values.yaml
          
          echo "ğŸ”„ Updating image tag to: ${{ needs.ci-pipeline.outputs.image-tag }}"
          
          # Update the image tag in values.yaml
          yq e '.image.tag = "${{ needs.ci-pipeline.outputs.image-tag }}"' -i charts/fastapi-ml/values.yaml
          
          echo "ğŸ“ Updated values.yaml:"
          cat charts/fastapi-ml/values.yaml

      - name: Commit and push deployment changes
        run: |
          cd deploy-repo
          
          # Configure git
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Check if there are changes
          if git diff --quiet charts/fastapi-ml/values.yaml; then
            echo "â„¹ï¸ No changes to commit"
          else
            # Commit and push changes
            git add charts/fastapi-ml/values.yaml
            git commit -m "chore: update fastapi-ml-app image to ${{ needs.ci-pipeline.outputs.image-tag }}

            - Updated by: ${{ github.actor }}
            - Source commit: ${{ github.sha }}
            - Build time: $(date -u)"
            
            git push
            
            echo "âœ… Deployment repository updated"
          fi

      - name: Trigger ArgoCD sync
        run: |
          echo "ğŸ”„ Triggering ArgoCD sync..."
          
          # Wait for Git changes to propagate
          sleep 15
          
          # Option 1: Using ArgoCD CLI (if available)
          if command -v argocd &> /dev/null; then
            argocd login ${{ env.ARGOCD_SERVER }} --username admin --password "${{ secrets.ARGOCD_PASSWORD }}" --insecure
            argocd app sync fastapi-ml --force
            argocd app wait fastapi-ml --timeout 300
          else
            # Option 2: Using curl API
            curl -X POST \
              -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d '{
                    "revision": "HEAD",
                    "prune": true,
                    "dryRun": false,
                    "strategy": {
                      "apply": {
                        "force": true
                      }
                    }
                  }' \
              "http://${{ env.ARGOCD_SERVER }}/api/v1/applications/fastapi-ml/sync" || echo "âš ï¸ ArgoCD sync API call failed"
          fi

      - name: Wait and verify deployment
        run: |
          echo "â³ Waiting for Kubernetes deployment..."
          
          # Wait for ArgoCD to process changes
          sleep 45
          
          # Check if namespace exists
          if ! kubectl get namespace fastapi-ml >/dev/null 2>&1; then
            echo "âš ï¸ Namespace fastapi-ml not found, ArgoCD may still be creating it..."
            sleep 30
          fi
          
          # Check deployment status
          if kubectl get deployment fastapi-ml -n fastapi-ml >/dev/null 2>&1; then
            echo "ğŸ“Š Deployment found, checking status..."
            kubectl rollout status deployment/fastapi-ml -n fastapi-ml --timeout=300s
            
            # Show deployment info
            kubectl get pods -n fastapi-ml -l app=fastapi-ml
            kubectl get svc -n fastapi-ml
            
            # Get service URL if available
            SERVICE_IP=$(kubectl get svc fastapi-ml -n fastapi-ml -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
            if [ "$SERVICE_IP" != "pending" ] && [ -n "$SERVICE_IP" ]; then
              echo "ğŸŒ Service available at: http://$SERVICE_IP"
              sleep 10  # Wait for LoadBalancer
              curl -f "http://$SERVICE_IP/health" && echo "âœ… Service health check passed!" || echo "âš ï¸ Service not yet ready"
            fi
          else
            echo "âš ï¸ Deployment not found. Check ArgoCD application status:"
            kubectl get applications -n argocd | grep fastapi || echo "ArgoCD application not found"
          fi

  # ğŸ“Š Summary Job
  summary:
    needs: [ci-pipeline, cd-pipeline]
    runs-on: [self-hosted, k3s, homelab]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "ğŸ“Š CI/CD Pipeline Summary"
          echo "========================="
          echo "ğŸ”¨ CI Status: ${{ needs.ci-pipeline.result }}"
          echo "ğŸš€ CD Status: ${{ needs.cd-pipeline.result }}"
          echo "ğŸ·ï¸ Image Tag: ${{ needs.ci-pipeline.outputs.image-tag }}"
          echo "ğŸ“¦ Registry: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}"
          echo "ğŸ¯ ArgoCD: http://${{ env.ARGOCD_SERVER }}"
          echo
          
          if [ "${{ needs.cd-pipeline.result }}" == "success" ]; then
            echo "ğŸ‰ Deployment completed successfully!"
            echo "âœ… Your FastAPI app should be running in the cluster"
            echo "ğŸ” Check: kubectl get pods -n fastapi-ml"
          else
            echo "âŒ Deployment encountered issues"
            echo "ğŸ”§ Check ArgoCD dashboard: http://${{ env.ARGOCD_SERVER }}"
          fi
